# SpiritEx Core (0500)


## Features

- Builtin `Member` service for user management and authentication.
	- User managed Api keys.
	- Automated session renewal.
- Builtin `Diagnostic` service for server information.
- Builtin `Sdk` service for dynamic generation of client SDKs and documentation.
- Comprehensive log tracing.
- Automatically mount service commands for all transports.
- Automatically register Mcp tools for all service commands.
- Dynamically generate client Sdks for all services.


## Server

The server is the core of the SpiritEx system.
Applications define and implement services that are hosted by the server and available on the network.
It provides a set of standard services that can be used by applications.
The server is responsible for managing the services and their dependencies.
It also provides a set of transports that can be used to access the services.


## Standard Services

### Diagnostic Service

The `Diagnostic Service` is publicly available and provides server information.
It can be used to verify that the server is running and obtain platform information.

***Methods***
- **ServerInfo**() : Gets server info.
- **ServerError**() : Throws a server error.


### Sdk Service

The `Sdk Service` is also publicly available and provides access to the server's Client SDKs and documentation.
It can be used to obtain the Client SDK for a specific service and user type.
It can also be used to obtain schema and documentation for network services.

***Methods***
- **NetworkUrls**() : Gets the server addresses for all services on the network.
- **Schema**( UserType ) : Gets the schema for all services hosted by this server.
- **Client**( Transport, Platform, UserType ) : Downloads the SDK Client as a single source file for the target transport and platform.
- **Documentation**( Transport, Platform, UserType, UseLinks ) : Downloads the SDK documentation as a single markdown file.


### Member Service

The `Member Service` is responsible for user management, authentication, and authorization.
It runs on top of an `Identity Provider` service (such as Clerk) which associates a user's email address with a password.

***Available Identity Providers***
- **Local** : Uses the local database to manage users and credentials.
- **Clerk** : Uses Clerk [https://clerk.com/] to manage users and authentication.
- **ClerkMock** : Uses a mock identity provider for testing purposes (always authenticates).

It is used to manage members and their access to the server.
It is also used by users to authenticate with the server.
This service can be disabled or overwritten by a custom implementation.

***Methods***
| **NewSession**( Strategy, Identifier, Secret ) | Authenticate with the network and retrieve a new network session and token. The new token is also returned in the Authorization header of the response |
| **NewNetworkToken**() | Generate a new network token for an existing session. The new token is also returned in the Authorization header of the response. |
| **GetMySession**() | Gets this session. |
| **ListMyApiKeys**() | Lists the ApiKeys owned by the current user. |
| **CreateMyApiKey**( Description, ExpirationMS ) | Creates an ApiKey for the current user. |
| **DestroyMyApiKey**( ApiKeyID ) | Destroys an ApiKey. |
| **GetMyApiKey**( ApiKeyID ) | Retrieves an ApiKey. |
| **LockMyApiKey**( ApiKeyID ) | Locks an ApiKey on the network. |
| **UnlockMyApiKey**( ApiKeyID ) | Unlocks an ApiKey on the network. |

Many more `Member` commands exist to manage sessions, api keys, etc.


## Application Services

Applications using `Core` can define and host new application services.
All services are remotable with any of the defined transports.
Application services are defined in a folder and provide files that define the service via a schema and
 an implementation file that codes the details of the service commands.

The distinction between schema and implementation is important because they are loaded
 at different points within the Server's intialization.


### Service Folder Structure

The server configuration file contains an entry for `services_folder` which specifies the root folder
 where the application's service files will be found.
This root folder will have a subfolder named for each application service.

```
Services/					<--- services_folder
	|_ Calc/				<--- Calc Service
		|_ CalcSchema.js
		|_ CalcService.js
		|_ other-files.js
	|_ Echo/				<--- Echo Service
	...
```

### Service Schema

The service schema will be named after the service (e.g. `EchoSchema.js`).
Each service can use json schema to define custom objects that are used by the service.
The schema also defines the service's interface and tells the transports which endpoints to make available to applications.

When the schema is loaded, is provided with an instance of the `Server` object.
This allows the schema to access the server's configuration and other services.

The service schema provides the structure to provide service entry points for each transport.
The service schema is also used to generate client documentation and SDKs for services (see the Sdk service).

```js
'use strict';
// Services/Echo/EchoSchema.js
// Definition file for the Echo service.

module.exports = function ( Server )
{
	return {

		$Objects: {}, // This service has no objects defined

		//---------------------------------------------------------------------
		// Echos the given text. Echo.EchoText( 'Hello' ) --> 'Hello'
		EchoText: {
			description: 'Echoes the given text.',
			groups: [],
			Arguments: { // <-- Json schema describing the command arguments
				type: 'object',
				properties: {
					Text: { type: 'string', description: 'The text to echo.' },
				},
				required: [ 'Text' ],
			},
			Returns: { // <-- Json schema describing the return value
				type: 'string',
				description: 'The echoed text.',
			},
		},

		//---------------------------------------------------------------------
		// Reverses the given text. Echo.ReverseText( 'Hello' ) --> 'olleH'
		ReverseText: {
			description: 'Reverses the given text.',
			groups: [],
			Arguments: {
				type: 'object',
				properties: {
					Text: { type: 'string', description: 'The text to be reversed.' },
				},
				required: [ 'Text' ],
			},
			Returns: {
				type: 'string',
				description: 'The reversed text.',
			},
		},

	};
};
```


### Service Implementation

The service implementation file will be named after the service (e.g. `EchoService.js`).
This file is read during the server startup and is used to create the service object.

The service implementation file is provided with an instance of the `Server` object.
This allows the service implementation to access the server's configuration and other services.

```js
'use strict';
// Services/Echo/EchoService.js
// Implementation file for the Echo service.

const SERVICE_NAME = 'Echo';

module.exports = function ( Server )
{
	var Logger = Server.LogManager.NewLogger( { service: SERVICE_NAME } );

	//---------------------------------------------------------------------
	var Service = {
		_Control: {
			service_name: SERVICE_NAME,
			service_enabled: Server.Config.Services[ SERVICE_NAME ].enabled,
			Startup:
				async function ()
				{
					Logger.debug( `Starting ${SERVICE_NAME} service ...` );
					Logger.debug( `${SERVICE_NAME} service started.` );
					return;
				},
			Shutdown:
				async function ()
				{
					Logger.debug( `Shutting down ${SERVICE_NAME} service ...` );
					Logger.debug( `${SERVICE_NAME} service stopped.` );
					return;
				},
		},
	};

	//---------------------------------------------------------------------
	Service.EchoText =
		async function ( Text, ApiContext )
		{
			Logger.debug( `Echoing the text: [${Text}].` );
			return Text;
		};

	//---------------------------------------------------------------------
	Service.ReverseText =
		async function ( Text, ApiContext )
		{
			Logger.debug( `Reversing the text: [${Text}].` );
			var text = Text.split( '' ).reverse().join( '' );
			return text;
		};

	//---------------------------------------------------------------------
	return Service;
}
```


## Standard Transports

### InProcess Transport


### Http Transport

**Websocket Plugin**

**Mcp Plugin**


### Amqp Transport


## Minimal Example

```js

const ServerConfig = require( './Config.js' );
const ServerFactory = require( 'spiritex-core-0500'  );
const Server = ServerFactory( ServerConfig );

await Server.StartupServer();

...

await Server.ShutdownServer();

```


## Server Configuration

Server configuration is provided by a configuration object that can be read from a JSON file or created in code.
It is typical practice to have different configuration files for each server instance or environment.
For example, you might have a configuration files for testing, staging, and production.

The Server Configuration object has these basic sections:
- General: Contains the server name, version, and other general information.
- Logger: Controls the logger output.
- Network: Controls the network settings. The network describes a set of servers and their hosted services. 
	- Credentials: Contains the network credentials. Used by applications when making service calls within the network.
	- Urls: Contains the urls for each service. These urls can point to the local server instance or to another server in the network. This is used by the Client SDK when making service calls.
- Transports: Enable, disable, and configure the three transports: InProcess, Http, and Amqp.
- Services: Enable, disable, and configure the services hosted by the server.


## Network User Types

There are three main user types in the network:
- Network: This is the highest level of access. It can access all services in the network.
- Service: Used by services, it allows services to call each other.
- User: Used by applications, it allows applications to call services on behalf of users.

All three of these user types require a user account such as those managed by the `Member Service`.
This allows services to track who is calling which endpoints.
Services can also further segeregate certian users by emplying the `metadata` field of the user account.


## Client SDK and Documentation Generation

The server can generate a client SDK and documentation for each service.
The SDK is generated from the service schema and can be used to access the service from a client application.
The documentation is generated from the service schema and can be used to understand the service's interface.

The resulting Client SDK and documentation will contain all services defined in the server.
This includes services that are disabled in the service's configuration.
In these cases, the Client SDK will rely on the `Network.Urls` configuration to access the correct service implementation.

The Client SDK is self-contained and can be used to access services from any application.
The Client SDK can also be used by Javascript applications running in a browser.
Part od the Server's initialization is to generate a complete set of Client SDKs for all services defined in the network.
It then loads the Client SDK and exposes it to applications via the `Server.ServiceClient` object.
This allows applications to access any service in the network without having to know the specific server that hosts the service.

When the Client SDK is generated, it is generated for each of the three main user types: Network, Service, and User.


## Peer-To-Peer Server Instances

The server can be configured to run in peer-to-peer mode.
Services can be run by only certain instancesare defined by the Server and can be disabled in one instance and proxied to by another instance.
This is done by disabling a service and supplying the url of the server that hosts the service in the `Network.Urls` configuration.
In this mode, the server will connect to other servers and share services.
This allows for a distributed system where services can be accessed from any server.



